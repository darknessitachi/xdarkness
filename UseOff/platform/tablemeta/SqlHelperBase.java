package tablemeta;

/// SqlHelperBase,用于数据库存取操作的一些基类封装,静态类,不提供实例化方法。
public  class SqlHelperBase 
{
//	#region SqlConnection Cn(string m_connectionString)
//	/// <summary>
//	/// 取得本类当前所用的活动链接
//	/// </summary>
//	public static SqlConnection Cn(string m_connectionString)
//	{
//		SqlConnection cn = new SqlConnection(m_connectionString);
//		cn.Open();
//		return cn;
//	}
//	#endregion
//
//	#region deleted
//	/*
//	/// <summary>
//	/// Execute a SqlCommand (that returns a resultset and takes no parameters) against the database specified in 
//	/// the connection string. 
//	/// </summary>
//	/// <remarks>
//	/// e.g.:  
//	///  SqlDataReader dr = ExecuteReader(connString, CommandType.StoredProcedure, "GetOrders");
//	/// </remarks>
//	/// <param name="connectionString">a valid connection string for a SqlConnection</param>
//	/// <param name="commandType">the CommandType (stored procedure, text, etc.)</param>
//	/// <param name="commandText">the stored procedure name or T-SQL command</param>
//	/// <returns>a SqlDataReader containing the resultset generated by the command</returns>
//	public static SqlDataReader ExecuteReader(string connectionString, CommandType commandType, string commandText)
//	{
//		//pass through the call providing null for the set of SqlParameters
//		return ExecuteReader(connectionString, commandType, commandText, (SqlParameter[])null);
//	}
//
//	/// <summary>
//	/// Execute a SqlCommand (that returns a resultset) against the database specified in the connection string 
//	/// using the provided parameters.
//	/// </summary>
//	/// <remarks>
//	/// e.g.:  
//	///  SqlDataReader dr = ExecuteReader(connString, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
//	/// </remarks>
//	/// <param name="connectionString">a valid connection string for a SqlConnection</param>
//	/// <param name="commandType">the CommandType (stored procedure, text, etc.)</param>
//	/// <param name="commandText">the stored procedure name or T-SQL command</param>
//	/// <param name="commandParameters">an array of SqlParamters used to execute the command</param>
//	/// <returns>a SqlDataReader containing the resultset generated by the command</returns>
//	public static SqlDataReader ExecuteReader(string connectionString, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
//	{
//		//create & open a SqlConnection
//		SqlConnection cn = new SqlConnection(connectionString);
//		cn.Open();
//
//		try
//		{
//			//call the private overload that takes an internally owned connection in place of the connection string
//			return ExecuteReader(cn, null, commandType, commandText, commandParameters, SqlConnectionOwnership.Internal);
//		}
//		catch
//		{
//			//if we fail to return the SqlDatReader, we need to close the connection ourselves
//			cn.Close();
//			throw;
//		}
//	}
//
//	/// <summary>
//	/// Execute a stored procedure via a SqlCommand (that returns a resultset) against the database specified in 
//	/// the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
//	/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
//	/// </summary>
//	/// <remarks>
//	/// This method provides no access to output parameters or the stored procedure's return value parameter.
//	/// 
//	/// e.g.:  
//	///  SqlDataReader dr = ExecuteReader(connString, "GetOrders", 24, 36);
//	/// </remarks>
//	/// <param name="connectionString">a valid connection string for a SqlConnection</param>
//	/// <param name="spName">the name of the stored procedure</param>
//	/// <param name="parameterValues">an array of objects to be assigned as the input values of the stored procedure</param>
//	/// <returns>a SqlDataReader containing the resultset generated by the command</returns>
//	public static SqlDataReader ExecuteReader(string connectionString, string spName, params object[] parameterValues)
//	{
//		//if we receive parameter values, we need to figure out where they go
//		if ((parameterValues != null) && (parameterValues.Length > 0))
//		{
//			//pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
//			SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connectionString, spName);
//
//			//assign the provided values to these parameters based on parameter order
//			AssignParameterValues(commandParameters, parameterValues);
//
//			//call the overload that takes an array of SqlParameters
//			return ExecuteReader(connectionString, CommandType.StoredProcedure, spName, commandParameters);
//		}
//		//otherwise we can just call the SP without params
//		else
//		{
//			return ExecuteReader(connectionString, CommandType.StoredProcedure, spName);
//		}
//	}
//
//	/// <summary>
//	/// this enum is used to indicate whether the connection was provided by the caller, or created by SqlHelper, so that
//	/// we can set the appropriate CommandBehavior when calling ExecuteReader()
//	/// </summary>
//	private enum SqlConnectionOwnership
//	{
//		/// <summary>Connection is owned and managed by SqlHelper</summary>
//		Internal,
//		/// <summary>Connection is owned and managed by the caller</summary>
//		External
//	}
//
//	/// <summary>
//	/// Execute a SqlCommand (that returns a resultset and takes no parameters) against the provided SqlTransaction. 
//	/// </summary>
//	/// <remarks>
//	/// e.g.:  
//	///  SqlDataReader dr = ExecuteReader(trans, CommandType.StoredProcedure, "GetOrders");
//	/// </remarks>
//	/// <param name="transaction">a valid SqlTransaction</param>
//	/// <param name="commandType">the CommandType (stored procedure, text, etc.)</param>
//	/// <param name="commandText">the stored procedure name or T-SQL command</param>
//	/// <returns>a SqlDataReader containing the resultset generated by the command</returns>
//	public static SqlDataReader ExecuteReader(SqlTransaction transaction, CommandType commandType, string commandText)
//	{
//		//pass through the call providing null for the set of SqlParameters
//		return ExecuteReader(transaction, commandType, commandText, (SqlParameter[])null);
//	}
//
//	/// <summary>
//	/// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified SqlConnection 
//	/// using the provided parameter values.  This method will query the database to discover the parameters for the 
//	/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
//	/// </summary>
//	/// <remarks>
//	/// This method provides no access to output parameters or the stored procedure's return value parameter.
//	/// 
//	/// e.g.:  
//	///  SqlDataReader dr = ExecuteReader(conn, "GetOrders", 24, 36);
//	/// </remarks>
//	/// <param name="connection">a valid SqlConnection</param>
//	/// <param name="spName">the name of the stored procedure</param>
//	/// <param name="parameterValues">an array of objects to be assigned as the input values of the stored procedure</param>
//	/// <returns>a SqlDataReader containing the resultset generated by the command</returns>
//	public static SqlDataReader ExecuteReader(SqlConnection connection, string spName, params object[] parameterValues)
//	{
//		//if we receive parameter values, we need to figure out where they go
//		if ((parameterValues != null) && (parameterValues.Length > 0))
//		{
//			SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection.ConnectionString, spName);
//
//			AssignParameterValues(commandParameters, parameterValues);
//
//			return ExecuteReader(connection, CommandType.StoredProcedure, spName, commandParameters);
//		}
//		//otherwise we can just call the SP without params
//		else
//		{
//			return ExecuteReader(connection, CommandType.StoredProcedure, spName , (SqlParameter[])null);
//		}
//	}
//
//	/// <summary>
//	/// Execute a stored procedure via a SqlCommand (that returns a resultset) against the specified
//	/// SqlTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
//	/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
//	/// </summary>
//	/// <remarks>
//	/// This method provides no access to output parameters or the stored procedure's return value parameter.
//	/// 
//	/// e.g.:  
//	///  SqlDataReader dr = ExecuteReader(trans, "GetOrders", 24, 36);
//	/// </remarks>
//	/// <param name="transaction">a valid SqlTransaction</param>
//	/// <param name="spName">the name of the stored procedure</param>
//	/// <param name="parameterValues">an array of objects to be assigned as the input values of the stored procedure</param>
//	/// <returns>a SqlDataReader containing the resultset generated by the command</returns>
//	public static SqlDataReader ExecuteReader(SqlTransaction transaction, string spName, params object[] parameterValues)
//	{
//		//if we receive parameter values, we need to figure out where they go
//		if ((parameterValues != null) && (parameterValues.Length > 0))
//		{
//			SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection.ConnectionString, spName);
//
//			AssignParameterValues(commandParameters, parameterValues);
//
//			return ExecuteReader(transaction, CommandType.StoredProcedure, spName, commandParameters);
//		}
//		//otherwise we can just call the SP without params
//		else
//		{
//			return ExecuteReader(transaction, CommandType.StoredProcedure, spName , (SqlParameter[])null);
//		}
//	}
//
//	/// <summary>
//	/// Execute a SqlCommand (that returns a resultset and takes no parameters) against the provided SqlConnection. 
//	/// </summary>
//	/// <remarks>
//	/// e.g.:  
//	///  SqlDataReader dr = ExecuteReader(conn, CommandType.StoredProcedure, "GetOrders");
//	/// </remarks>
//	/// <param name="connection">a valid SqlConnection</param>
//	/// <param name="commandType">the CommandType (stored procedure, text, etc.)</param>
//	/// <param name="commandText">the stored procedure name or T-SQL command</param>
//	/// <returns>a SqlDataReader containing the resultset generated by the command</returns>
//	public static SqlDataReader ExecuteReader(SqlConnection connection, CommandType commandType, string commandText)
//	{
//		//pass through the call providing null for the set of SqlParameters
//		return ExecuteReader(connection, commandType, commandText, (SqlParameter[])null);
//	}
//
//	/// <summary>
//	/// Execute a stored procedure via a SqlCommand (that returns no resultset) against the database specified in 
//	/// the connection string using the provided parameter values.  This method will query the database to discover the parameters for the 
//	/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
//	/// </summary>
//	/// <remarks>
//	/// This method provides no access to output parameters or the stored procedure's return value parameter.
//	/// 
//	/// e.g.:  
//	///  int result = ExecuteNonQuery(connString, "PublishOrders", 24, 36);
//	/// </remarks>
//	/// <param name="connectionString">a valid connection string for a SqlConnection</param>
//	/// <param name="spName">the name of the stored prcedure</param>
//	/// <param name="parameterValues">an array of objects to be assigned as the input values of the stored procedure</param>
//	/// <returns>an int representing the number of rows affected by the command</returns>
//	public static int ExecuteNonQuery(string connectionString, string spName, params object[] parameterValues)
//	{
//		//if we receive parameter values, we need to figure out where they go
//		if ((parameterValues != null) && (parameterValues.Length > 0))
//		{
//			//pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
//			SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connectionString, spName);
//
//			//assign the provided values to these parameters based on parameter order
//			AssignParameterValues(commandParameters, parameterValues);
//
//			//call the overload that takes an array of SqlParameters
//			return ExecuteNonQuery(connectionString, CommandType.StoredProcedure, spName, commandParameters);
//		}
//		//otherwise we can just call the SP without params
//		else
//		{
//			return ExecuteNonQuery(connectionString, CommandType.StoredProcedure, spName);
//		}
//	}
//
//	/// <summary>
//	/// Execute a stored procedure via a SqlCommand (that returns no resultset) against the specified SqlConnection 
//	/// using the provided parameter values.  This method will query the database to discover the parameters for the 
//	/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
//	/// </summary>
//	/// <remarks>
//	/// This method provides no access to output parameters or the stored procedure's return value parameter.
//	/// 
//	/// e.g.:  
//	///  int result = ExecuteNonQuery(conn, "PublishOrders", 24, 36);
//	/// </remarks>
//	/// <param name="connection">a valid SqlConnection</param>
//	/// <param name="spName">the name of the stored procedure</param>
//	/// <param name="parameterValues">an array of objects to be assigned as the input values of the stored procedure</param>
//	/// <returns>an int representing the number of rows affected by the command</returns>
//	public static int ExecuteNonQuery(SqlConnection connection, string spName, params object[] parameterValues)
//	{
//		//if we receive parameter values, we need to figure out where they go
//		if ((parameterValues != null) && (parameterValues.Length > 0))
//		{
//			//pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
//			SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(connection.ConnectionString, spName);
//
//			//assign the provided values to these parameters based on parameter order
//			AssignParameterValues(commandParameters, parameterValues);
//
//			//call the overload that takes an array of SqlParameters
//			return ExecuteNonQuery(connection, CommandType.StoredProcedure, spName, commandParameters);
//		}
//		//otherwise we can just call the SP without params
//		else
//		{
//			return ExecuteNonQuery(connection, CommandType.StoredProcedure, spName);
//		}
//	}
//
//
//	/// <summary>
//	/// Execute a SqlCommand (that returns no resultset and takes no parameters) against the provided SqlConnection. 
//	/// </summary>
//	/// <remarks>
//	/// e.g.:  
//	///  int result = ExecuteNonQuery(conn, CommandType.StoredProcedure, "PublishOrders");
//	/// </remarks>
//	/// <param name="connection">a valid SqlConnection</param>
//	/// <param name="commandType">the CommandType (stored procedure, text, etc.)</param>
//	/// <param name="commandText">the stored procedure name or T-SQL command</param>
//	/// <returns>an int representing the number of rows affected by the command</returns>
//	public static int ExecuteNonQuery(SqlConnection connection, CommandType commandType, string commandText)
//	{
//		//pass through the call providing null for the set of SqlParameters
//		return ExecuteNonQuery(connection, commandType, commandText, (SqlParameter[])null);
//	}
//
//	/// <summary>
//	/// Execute a SqlCommand (that returns no resultset and takes no parameters) against the provided SqlTransaction. 
//	/// </summary>
//	/// <remarks>
//	/// e.g.:  
//	///  int result = ExecuteNonQuery(trans, CommandType.StoredProcedure, "PublishOrders");
//	/// </remarks>
//	/// <param name="transaction">a valid SqlTransaction</param>
//	/// <param name="commandType">the CommandType (stored procedure, text, etc.)</param>
//	/// <param name="commandText">the stored procedure name or T-SQL command</param>
//	/// <returns>an int representing the number of rows affected by the command</returns>
//	public static int ExecuteNonQuery(SqlTransaction transaction, CommandType commandType, string commandText)
//	{
//		//pass through the call providing null for the set of SqlParameters
//		return ExecuteNonQuery(transaction, commandType, commandText, (SqlParameter[])null);
//	}
//
//	/// <summary>
//	/// Execute a stored procedure via a SqlCommand (that returns no resultset) against the specified 
//	/// SqlTransaction using the provided parameter values.  This method will query the database to discover the parameters for the 
//	/// stored procedure (the first time each stored procedure is called), and assign the values based on parameter order.
//	/// </summary>
//	/// <remarks>
//	/// This method provides no access to output parameters or the stored procedure's return value parameter.
//	/// 
//	/// e.g.:  
//	///  int result = ExecuteNonQuery(conn, trans, "PublishOrders", 24, 36);
//	/// </remarks>
//	/// <param name="transaction">a valid SqlTransaction</param>
//	/// <param name="spName">the name of the stored procedure</param>
//	/// <param name="parameterValues">an array of objects to be assigned as the input values of the stored procedure</param>
//	/// <returns>an int representing the number of rows affected by the command</returns>
//	public static int ExecuteNonQuery(SqlTransaction transaction, string spName, params object[] parameterValues)
//	{
//		//if we receive parameter values, we need to figure out where they go
//		if ((parameterValues != null) && (parameterValues.Length > 0))
//		{
//			//pull the parameters for this stored procedure from the parameter cache (or discover them & populate the cache)
//			SqlParameter[] commandParameters = SqlHelperParameterCache.GetSpParameterSet(transaction.Connection.ConnectionString, spName);
//
//			//assign the provided values to these parameters based on parameter order
//			AssignParameterValues(commandParameters, parameterValues);
//
//			//call the overload that takes an array of SqlParameters
//			return ExecuteNonQuery(transaction, CommandType.StoredProcedure, spName, commandParameters);
//		}
//		//otherwise we can just call the SP without params
//		else
//		{
//			return ExecuteNonQuery(transaction, CommandType.StoredProcedure, spName);
//		}
//	}
//
//	/// <summary>
//	/// Execute a SqlCommand (that returns no resultset and takes no parameters) against the database specified in 
//	/// the connection string. 
//	/// </summary>
//	/// <remarks>
//	/// e.g.:  
//	///  int result = ExecuteNonQuery(connString, CommandType.StoredProcedure, "PublishOrders");
//	/// </remarks>
//	/// <param name="connectionString">a valid connection string for a SqlConnection</param>
//	/// <param name="commandType">the CommandType (stored procedure, text, etc.)</param>
//	/// <param name="commandText">the stored procedure name or T-SQL command</param>
//	/// <returns>an int representing the number of rows affected by the command</returns>
//	public static int ExecuteNonQuery(string connectionString, CommandType commandType, string commandText)
//	{
//		//pass through the call providing null for the set of SqlParameters
//		return ExecuteNonQuery(connectionString, commandType, commandText, (SqlParameter[])null);
//	}
//	*/
//	#endregion deleted
//
//	#region 为开放给直接调用存储过程，SQL事务等而添加的重载方法
//	#region AssignParameterValues
//	/// <summary>
//	/// This method assigns an array of values to an array of SqlParameters.
//	/// </summary>
//	/// <param name="commandParameters">array of SqlParameters to be assigned values</param>
//	/// <param name="parameterValues">array of objects holding the values to be assigned</param>
//	private static void AssignParameterValues(SqlParameter[] commandParameters, object[] parameterValues)
//	{
//		if ((commandParameters == null) || (parameterValues == null))
//		{
//			//do nothing if we get no data
//			return;
//		}
//
//		// we must have the same number of values as we pave parameters to put them in
//		if (commandParameters.Length != parameterValues.Length)
//		{
//			throw new ArgumentException("Parameter count does not match Parameter Value count.");
//		}
//
//		//iterate through the SqlParameters, assigning the values from the corresponding position in the 
//		//value array
//		for (int i = 0, j = commandParameters.Length; i < j; i++)
//		{
//			commandParameters[i].Value = parameterValues[i];
//		}
//	}
//	#endregion AssignParameterValues
//
//	#region AttachParameters
//	/// <summary>
//	/// This method is used to attach array of SqlParameters to a SqlCommand.
//	/// 
//	/// This method will assign a value of DbNull to any parameter with a direction of
//	/// InputOutput and a value of null.  
//	/// 
//	/// This behavior will prevent default values from being used, but
//	/// this will be the less common case than an intended pure output parameter (derived as InputOutput)
//	/// where the user provided no input value.
//	/// </summary>
//	/// <param name="command">The command to which the parameters will be added</param>
//	/// <param name="commandParameters">an array of SqlParameters tho be added to command</param>
//	private static void AttachParameters(SqlCommand command, SqlParameter[] commandParameters)
//	{
//		foreach (SqlParameter p in commandParameters)
//		{
//			//check for derived output value with no value assigned
//			if ((p.Direction == ParameterDirection.InputOutput) && (p.Value == null))
//			{
//				p.Value = DBNull.Value;
//			}
//
//			command.Parameters.Add(p);
//		}
//	}
//	#endregion AttachParameters
//
//	#region PrepareCommand
//	/// <summary>
//	/// This method opens (if necessary) and assigns a connection, transaction, command type and parameters 
//	/// to the provided command.
//	/// </summary>
//	/// <param name="command">the SqlCommand to be prepared</param>
//	/// <param name="connection">a valid SqlConnection, on which to execute this command</param>
//	/// <param name="transaction">a valid SqlTransaction, or 'null'</param>
//	/// <param name="commandType">the CommandType (stored procedure, text, etc.)</param>
//	/// <param name="commandText">the stored procedure name or T-SQL command</param>
//	/// <param name="commandParameters">an array of SqlParameters to be associated with the command or 'null' if no parameters are required</param>
//	private static void PrepareCommand(SqlCommand command, SqlConnection connection, SqlTransaction transaction, CommandType commandType, string commandText, SqlParameter[] commandParameters)
//	{
//		//if the provided connection is not open, we will open it
//		if (connection.State != ConnectionState.Open)
//		{
//			connection.Open();
//		}
//
//		//associate the connection with the command
//		command.Connection = connection;
//
//		//set the command text (stored procedure name or SQL statement)
//		command.CommandText = commandText;
//
//		//if we were provided a transaction, assign it.
//		if (transaction != null)
//		{
//			command.Transaction = transaction;
//		}
//
//		//set the command type
//		command.CommandType = commandType;
//
//		//attach the command parameters if they are provided
//		if (commandParameters != null)
//		{
//			AttachParameters(command, commandParameters);
//		}
//
//		return;
//	}
//	#endregion PrepareCommand
//
//	#region ExecuteReader
//
//	/// <summary>
//	/// Create and prepare a SqlCommand, and call ExecuteReader with the appropriate CommandBehavior.
//	/// </summary>
//	/// <remarks>
//	/// If we created and opened the connection, we want the connection to be closed when the DataReader is closed.
//	/// 
//	/// If the caller provided the connection, we want to leave it to them to manage.
//	/// </remarks>
//	/// <param name="connection">a valid SqlConnection, on which to execute this command</param>
//	/// <param name="transaction">a valid SqlTransaction, or 'null'</param>
//	/// <param name="commandType">the CommandType (stored procedure, text, etc.)</param>
//	/// <param name="commandText">the stored procedure name or T-SQL command</param>
//	/// <param name="commandParameters">an array of SqlParameters to be associated with the command or 'null' if no parameters are required</param>
//	/// <returns>SqlDataReader containing the results of the command</returns>
//	private static SqlDataReader ExecuteReaderPrivate(SqlConnection connection, SqlTransaction transaction, CommandType commandType, string commandText, SqlParameter[] commandParameters)
//	{
//		//create a command and prepare it for execution
//		SqlCommand cmd = new SqlCommand();
//		PrepareCommand(cmd, connection, transaction, commandType, commandText, commandParameters);
//
//		//create a reader
//		SqlDataReader dr;
//
//		// call ExecuteReader with the appropriate CommandBehavior
//		dr = cmd.ExecuteReader();
//
//		// detach the SqlParameters from the command object, so they can be used again.
//		cmd.Parameters.Clear();
//
//		return dr;
//	}
//
//	/// <summary>
//	/// Execute a SqlCommand (that returns a resultset) against the specified SqlConnection 
//	/// using the provided parameters.
//	/// </summary>
//	/// <remarks>
//	/// e.g.:  
//	///  SqlDataReader dr = ExecuteReader(conn, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
//	/// </remarks>
//	/// <param name="connection">a valid SqlConnection</param>
//	/// <param name="commandType">the CommandType (stored procedure, text, etc.)</param>
//	/// <param name="commandText">the stored procedure name or T-SQL command</param>
//	/// <param name="commandParameters">an array of SqlParamters used to execute the command</param>
//	/// <returns>a SqlDataReader containing the resultset generated by the command</returns>
//	public static SqlDataReader ExecuteReader(SqlConnection connection, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
//	{
//		//pass through the call to the private overload using a null transaction value and an externally owned connection
//		return ExecuteReaderPrivate(connection, (SqlTransaction)null, commandType, commandText, commandParameters);
//	}
//
//
//	/// <summary>
//	/// Execute a SqlCommand (that returns a resultset) against the specified SqlTransaction
//	/// using the provided parameters.
//	/// </summary>
//	/// <remarks>
//	/// e.g.:  
//	///   SqlDataReader dr = ExecuteReader(trans, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
//	/// </remarks>
//	/// <param name="transaction">a valid SqlTransaction</param>
//	/// <param name="commandType">the CommandType (stored procedure, text, etc.)</param>
//	/// <param name="commandText">the stored procedure name or T-SQL command</param>
//	/// <param name="commandParameters">an array of SqlParamters used to execute the command</param>
//	/// <returns>a SqlDataReader containing the resultset generated by the command</returns>
//	public static SqlDataReader ExecuteReader(SqlTransaction transaction, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
//	{
//		//pass through to private overload, indicating that the connection is owned by the caller
//		return ExecuteReaderPrivate(transaction.Connection, transaction, commandType, commandText, commandParameters);
//	}
//
//	#endregion ExecuteReader
//
//	#endregion 为开放给直接调用存储过程，SQL事务等而添加的重载方法
//
//	#region PrepareCommand
//
//	/// <summary>
//	/// This method opens (if necessary) and assigns a connection, transaction, command type and parameters 
//	/// to the provided command.
//	/// </summary>
//	/// <param name="m_connectionString">the SqlConnection to be connect</param>
//	/// <param name="command">the SqlCommand to be prepared</param>
//	/// <param name="commandType">the CommandType (stored procedure, text, etc.)</param>
//	/// <param name="commandText">the stored procedure name or T-SQL command</param>
//	private static void PrepareCommand(string m_connectionString ,SqlCommand command, CommandType commandType, string commandText)
//	{
//		//associate the connection with the command
//		command.Connection = Cn(m_connectionString);
//
//		//set the command text (stored procedure name or SQL statement)
//		command.CommandText = commandText;
//
//		//set the command type
//		command.CommandType = commandType;
//
//		return;
//	}
//	#endregion
//
//	#region ExecuteNonQuery
//	/// <summary>
//	/// Execute a Text SqlCommand (that returns no resultset)
//	/// 
//	/// e.g.:  
//	/// int result = ExecuteNonQuery("update a set b=1"); 
//	/// </summary>
//	/// <param name="m_connectionString">the SqlConnection to be connect</param>
//	/// <param name="commandText"> the stored procedure name or T-SQL command </param>
//	/// <returns> returns an int representing the number of rows affected by the command</returns>
//	public static int ExecuteNonQuery(string m_connectionString ,string commandText)
//	{
//		SqlCommand cmd = new SqlCommand();
//		try
//		{
//			//create a command and prepare it for execution
//			PrepareCommand(m_connectionString ,cmd, CommandType.Text, commandText);
//		
//			//finally, execute the command.
//			int retval = cmd.ExecuteNonQuery();
//		
//			// detach the SqlParameters from the command object, so they can be used again.
//			cmd.Parameters.Clear();
//			return retval;
//		}
//		catch(Exception e)
//		{
//			throw e;
//		}
//		finally
//		{
//			try
//			{
//				cmd.Connection.Dispose();
//				cmd.Dispose();
//			}
//			catch
//			{
//			}
//		}
//	}
//
//	/// <summary>
//	/// Execute a SqlCommand (that returns no resultset) against the database specified in the connection string 
//	/// using the provided parameters.
//	/// </summary>
//	/// <remarks>
//	/// e.g.:  
//	///  int result = ExecuteNonQuery(connString, CommandType.StoredProcedure, "PublishOrders", new SqlParameter("@prodid", 24));
//	/// </remarks>
//	/// <param name="connectionString">a valid connection string for a SqlConnection</param>
//	/// <param name="commandType">the CommandType (stored procedure, text, etc.)</param>
//	/// <param name="commandText">the stored procedure name or T-SQL command</param>
//	/// <param name="commandParameters">an array of SqlParamters used to execute the command</param>
//	/// <returns>an int representing the number of rows affected by the command</returns>
//	public static int ExecuteNonQuery(string connectionString, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
//	{
//		//create & open a SqlConnection, and dispose of it after we are done.
//		using (SqlConnection cn = new SqlConnection(connectionString))
//		{
//			cn.Open();
//
//			//call the overload that takes a connection in place of the connection string
//			return ExecuteNonQuery(cn, commandType, commandText, commandParameters);
//		}
//	}
//
//	/// <summary>
//	/// Execute a SqlCommand (that returns no resultset) against the specified SqlConnection 
//	/// using the provided parameters.
//	/// </summary>
//	/// <remarks>
//	/// e.g.:  
//	///  int result = ExecuteNonQuery(conn, CommandType.StoredProcedure, "PublishOrders", new SqlParameter("@prodid", 24));
//	/// </remarks>
//	/// <param name="connection">a valid SqlConnection</param>
//	/// <param name="commandType">the CommandType (stored procedure, text, etc.)</param>
//	/// <param name="commandText">the stored procedure name or T-SQL command</param>
//	/// <param name="commandParameters">an array of SqlParamters used to execute the command</param>
//	/// <returns>an int representing the number of rows affected by the command</returns>
//	public static int ExecuteNonQuery(SqlConnection connection, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
//	{
//		//create a command and prepare it for execution
//		SqlCommand cmd = new SqlCommand();
//		PrepareCommand(cmd, connection, (SqlTransaction)null, commandType, commandText, commandParameters);
//
//		//finally, execute the command.
//		int retval = cmd.ExecuteNonQuery();
//
//		// detach the SqlParameters from the command object, so they can be used again.
//		cmd.Parameters.Clear();
//		return retval;
//	}
//
//	/// <summary>
//	/// Execute a SqlCommand (that returns no resultset) against the specified SqlTransaction
//	/// using the provided parameters.
//	/// </summary>
//	/// <remarks>
//	/// e.g.:  
//	///  int result = ExecuteNonQuery(trans, CommandType.StoredProcedure, "GetOrders", new SqlParameter("@prodid", 24));
//	/// </remarks>
//	/// <param name="transaction">a valid SqlTransaction</param>
//	/// <param name="commandType">the CommandType (stored procedure, text, etc.)</param>
//	/// <param name="commandText">the stored procedure name or T-SQL command</param>
//	/// <param name="commandParameters">an array of SqlParamters used to execute the command</param>
//	/// <returns>an int representing the number of rows affected by the command</returns>
//	public static int ExecuteNonQuery(SqlTransaction transaction, CommandType commandType, string commandText, params SqlParameter[] commandParameters)
//	{
//		//create a command and prepare it for execution
//		SqlCommand cmd = new SqlCommand();
//		PrepareCommand(cmd, transaction.Connection, transaction, commandType, commandText, commandParameters);
//
//		//finally, execute the command.
//		int retval = cmd.ExecuteNonQuery();
//
//		// detach the SqlParameters from the command object, so they can be used again.
//		cmd.Parameters.Clear();
//		return retval;
//	}
//
//	#endregion
//	
//	#region ExecuteDataset
//	/// <summary>
//	///  Execute a SqlCommand (that returns a resultset)
//	/// 
//	/// e.g.:  
//	///  DataSet ds = ExecuteDataset("select * from a");
//	/// </summary>
//	/// <param name="m_connectionString">the SqlConnection to be connect</param>
//	/// <param name="commandText">the T-SQL command</param>
//	/// <returns>returns a dataset containing the resultset generated by the command</returns>
//	public static DataSet ExecuteDataset(string m_connectionString ,string commandText)
//	{
//		SqlCommand cmd = new SqlCommand();
//		try
//		{
//			//create a command and prepare it for execution
//			PrepareCommand(m_connectionString ,cmd, CommandType.Text, commandText);
//
//			//create the DataAdapter & DataSet
//			SqlDataAdapter da = new SqlDataAdapter(cmd);
//			DataSet ds = new DataSet();
//
//			//fill the DataSet using default values for DataTable names, etc.
//			da.Fill(ds);
//
//			// detach the SqlParameters from the command object, so they can be used again.			
//			cmd.Parameters.Clear();
//
//			//return the dataset
//			return ds;
//		}
//		catch(Exception e)
//		{
//			throw e;
//		}
//		finally
//		{
//			try
//			{
//				cmd.Connection.Dispose();
//				cmd.Dispose();
//			}
//			catch
//			{
//			}
//		}
//	}
//	#endregion
//
//	#region ExecuteDatatable
//	/// <summary>
//	/// 使用查询语句取得一个DataTable
//	/// </summary>
//	/// <param name="m_connectionString">数据库连接字符串</param>
//	/// <param name="commandText">查询语名,形如“select * from a where b=1”</param>
//	/// <returns>DataTable</returns>
//	public static DataTable ExecuteDatatable(string m_connectionString ,string commandText)
//	{
//		return ExecuteDataset(m_connectionString ,commandText).Tables[0];
//	}
//	#endregion
//
//	#region ExecuteReader
//	
//	/// <summary>
//	/// Create and prepare a SqlCommand, and call ExecuteReader with the appropriate CommandBehavior.
//	/// </summary>
//	/// <param name="m_connectionString">the SqlConnection to be connect</param>
//	/// <param name="commandText">the T-SQL command</param>
//	/// <returns>SqlDataReader containing the results of the command</returns>
//	public static SqlDataReader ExecuteReader(string m_connectionString ,string commandText)
//	{	
//		//create a command and prepare it for execution
//		SqlCommand cmd = new SqlCommand();
//		try
//		{
//			PrepareCommand(m_connectionString ,cmd, CommandType.Text, commandText);
//			
//			//create a reader
//			SqlDataReader dr = cmd.ExecuteReader();
//			// detach the SqlParameters from the command object, so they can be used again.
//			cmd.Parameters.Clear();
//			return dr;
//		}
//		catch(Exception e)
//		{
//			throw e;
//		}
//		finally
//		{
//			try
//			{
//				cmd.Connection.Dispose();
//				cmd.Dispose();
//			}
//			catch
//			{
//			}
//		}
//	}
//	#endregion
//
//	#region ExecuteDatarow
//	/// <summary>
//	///  Execute a SqlCommand (that returns a resultset)
//	/// 
//	/// e.g.:  
//	///  DataRow dr = ExecuteDatarow("select * from a");
//	/// </summary>
//	/// <param name="m_connectionString">the SqlConnection to be connect</param>
//	/// <param name="commandText">the T-SQL command</param>
//	/// <returns>returns a datarow containing the resultset generated by the command</returns>
//	public static DataRow ExecuteDatarow(string m_connectionString ,string commandText)
//	{
//		DataSet ds = ExecuteDataset(m_connectionString ,commandText);
//		//return the datarow
//		if (ds.Tables[0].Rows.Count>0)
//			return ds.Tables[0].Rows[0];
//		else
//			return (DataRow)null;
//	}
//	#endregion
//
//	#region ExecuteScalar
//	/// <summary>
//	///  Execute a SqlCommand (that returns a 1x1 resultset) 
//	///  
//	/// e.g.:  
//	///  int orderCount = (int)ExecuteScalar("select max(b) from a");
//	/// </summary>
//	/// <param name="m_connectionString">the SqlConnection to be connect</param>
//	/// <param name="commandText">SqlCommand Text</param>
//	/// <returns> returns an object containing the value in the 1x1 resultset generated by the command</returns>
//	public static object ExecuteScalar(string m_connectionString ,string commandText)
//	{
//		//create a command and prepare it for execution
//		SqlCommand cmd = new SqlCommand();
//		try
//		{
//			PrepareCommand(m_connectionString ,cmd, CommandType.Text, commandText);
//		
//			//execute the command & return the results
//			object retval = cmd.ExecuteScalar();
//
//		
//			// detach the SqlParameters from the command object, so they can be used again.
//			cmd.Parameters.Clear();
//			return retval;
//		}
//		catch(Exception e)
//		{
//			throw e;
//		}
//		finally
//		{
//			try
//			{
//				cmd.Connection.Dispose();
//				cmd.Dispose();
//			}
//			catch
//			{
//			}
//		}
//	}
//
//	/// <summary>
//	/// 对ExecuteScalar方法的扩展，将结果转化为string
//	/// 本函数对查询结果为空时返回""，以防调用者未加检测而报错（这也是编写本函数的目的）
//	/// </summary>
//	/// <param name="m_connectionString">数据库连接字符串</param>
//	/// <param name="commandText">sql语句，形如“select usrname from usr where id=3”</param>
//	/// <returns>一个string值，若查询未得到一行记录，则返回""</returns>
//	public static string ExecuteScalarString(string m_connectionString ,string commandText)
//	{
//		object retval = ExecuteScalar(m_connectionString ,commandText);
//		if (retval == null)
//			return "";
//		return retval.ToString();
//	}
//	#endregion
//
//	#region GetPK
//	/// <summary>
//	///  Execute a SqlCommand (that returns an int number for the table's max ID for insert) 
//	///  
//	/// e.g.:  
//	///  int newUserIdForInsert = SqlHelperBase.GetPK("users","userId")
//	///  
//	/// </summary>
//	/// <param name="m_connectionString">the SqlConnection to be connect</param>
//	/// <param name="tableName">table's name</param>
//	/// <param name="columnName">columnName's name,the column must be the PK and not an increment column</param>
//	/// <returns> returns an int value</returns>
//	public static int GetPK(string m_connectionString ,string tableName, string columnName)
//	{
//		return int.Parse(ExecuteScalar(m_connectionString ,"select isnull(max(" + columnName + "),0)+1 as col from " + tableName).ToString());
//	}
//	/// <summary>
//	///  Execute a SqlCommand (that returns an int number for the table's max ID for insert) 
//	///  
//	/// e.g.:  
//	///  int newUserIdForInsert = SqlHelperBase.GetPK("users","userId",20,30)
//	///  取得在20-30之间的一个可插入值
//	/// </summary>
//	/// <param name="m_connectionString">the SqlConnection to be connect</param>
//	/// <param name="tableName">table's name</param>
//	/// <param name="columnName">columnName's name,the column must be the PK and not an increment column</param>
//	/// <param name="minValue"></param>
//	/// <param name="maxValue"></param>
//	/// <returns> returns an int value</returns>
//	public static int GetPK(string m_connectionString ,string tableName, string columnName, int minValue, int maxValue)
//	{
//		return int.Parse(ExecuteScalar(m_connectionString ,"select isnull(max(" + columnName + ")," + (minValue-1).ToString() + ")+1 as col from " + tableName + " where " + columnName + ">=" + minValue + " and " + columnName + "<" + maxValue).ToString());
//	}
//	#endregion
//
//	#region GetInsertedPK
//	/// <summary>
//	/// 取得指定表最后一次插入的ID，若无法取得，则返回int.MinValue
//	/// 注意：未测试本函数对“某表同时有一自增长列和一主键列”的情形
//	/// 注意：若某表的主键字段不是数字型（例如“用客户名称作为主键”的情形），则调用此函数可能引起运行时错误
//	/// </summary>
//	/// <param name="m_connectionString">数据库连接字符串</param>
//	/// <param name="tableName">被指定的表</param>
//	/// <returns>一个int型的值</returns>
//	public static int GetInsertedPK(string m_connectionString ,string tableName)
//	{
//		object obj = ExecuteScalar(m_connectionString ,"SELECT IDENT_CURRENT('" + tableName + "')");
//		if (obj == null)
//			return int.MinValue;
//		return int.Parse(obj.ToString());
//	}
//	#endregion
//
//	#region GetIndexId(string tableName,string columnName,string m_where)
//
//	/// <summary>
//	/// 取得指定表的indexId,用于插入
//	/// 返回一个可插入的string型值
//	/// 因为此函数主要用于操作者在操作界面（例如添加新用户界面）上对“排序号”字段的默认值提供
//	/// 所以返回string型
//	/// </summary>
//	/// <param name="m_connectionString">数据库连接字符串</param>
//	/// <param name="tableName">表名，例如“usr”</param>
//	/// <param name="columnName">列名，例如“indexId”</param>
//	/// <param name="m_where">不带“where”关键字的条件语名，例如“deptId=3”表示“在单位ID为3的所有人员中的排序”</param>
//	/// <returns>返回一个可插入的string型值(在已有的最大值上加100，若无对比，则返回100)</returns>
//	public static string GetIndexId(string m_connectionString ,string tableName,string columnName,string m_where)
//	{
//		return GetIndexId(m_connectionString ,tableName,columnName,m_where,100);
//	}
//
//	/// <summary>
//	/// 取得指定表的indexId,用于插入
//	/// 返回一个可插入的string型值
//	/// 因为此函数主要用于操作者在操作界面（例如添加新用户界面）上对“排序号”字段的默认值提供
//	/// 所以返回string型
//	/// </summary>
//	/// <param name="m_connectionString">数据库连接字符串</param>
//	/// <param name="tableName">表名，例如“usr”</param>
//	/// <param name="columnName">列名，例如“indexId”</param>
//	/// <param name="m_where">不带“where”关键字的条件语名，例如“deptId=3”表示“在单位ID为3的所有人员中的排序”</param>
//	/// <param name="amplitude">在已有的最大值上加该数作为返回值</param>
//	/// <returns>返回一个可插入的string型值(在已有的最大值上加amplitude，若无对比，则返回amplitude)</returns>
//	public static string GetIndexId(string m_connectionString ,string tableName,string columnName,string m_where,int amplitude)
//	{
//		return ExecuteScalarString(m_connectionString ,"select isnull(max(cast(" + columnName + " as bigint)),0)+" + amplitude.ToString() + " as col from " + tableName + " where " + m_where);
//	}
//	#endregion
//
//	#region DataRowExists
//
//	/// <summary>
//	/// 判断是否在 tableName 表中已存在符合 m_where 条件的记录
//	/// </summary>
//	/// <param name="m_connectionString">数据库连接字符串</param>
//	/// <param name="tableName">表名</param>
//	/// <param name="m_where">where条件，不可包含“where”关键字</param>
//	/// <returns>存在则返回true,否则返回false</returns>
//	public static bool DataRowExists(string m_connectionString ,string tableName, string m_where)
//	{
//		return DataRowCount(m_connectionString ,tableName, m_where) > 0;
//	}
//
//	/// <summary>
//	/// 得到在 tableName 表中符合 m_where 条件的记录行数
//	/// </summary>
//	/// <param name="m_connectionString">数据库连接字符串</param>
//	/// <param name="tableName">表名</param>
//	/// <param name="m_where">where条件，不可包含“where”关键字</param>
//	/// <returns>返回在 tableName 表中符合 m_where 条件的记录行数</returns>
//	public static int DataRowCount(string m_connectionString ,string tableName, string m_where)
//	{
//		return int.Parse(ExecuteScalarString(m_connectionString ,"select count(" + tableName + "." + TableStructList.Get(tableName).Primary.Name + ") from " + tableName + " where " + m_where));
//	}
//	#endregion DataRowExists
//
//	#region Get GUID()
//	/// <summary>
//	/// 利用数据库取一个GUID，注意每次获得的此值均是不同的
//	/// </summary>
//	public static string GUID(string m_connectionString)
//	{
//		string s = ExecuteScalarString(m_connectionString ,"SELECT NEWID()").ToUpper();
//		if (s.IndexOf("{") != 0)
//		{
//			return "{" + s + "}";
//		}
//		else
//		{
//			return s;
//		}
//	}
//	#endregion Get GUID()
//
//	#region GetResultString
//	/// <summary>
//	/// 取得一单列多行结果，将结果用“,”号分隔返回一个字符串
//	/// 例如：“select distinct tablename from tailorformcol”
//	/// 返回：“zfw,sbw,affair,commfun,……”
//	/// </summary>
//	/// <param name="m_connectionString"></param>
//	/// <param name="commandText"></param>
//	/// <returns></returns>
//	public static string GetResultString(string m_connectionString , string commandText)
//	{
//		DataTable dt = ExecuteDatatable(m_connectionString , commandText);
//		string s = "";
//		for (int i = 0; i < dt.Rows.Count; i++)
//		{
//			if (i > 0)
//			{
//				s += ",";
//			}
//			s += dt.Rows[i][0].ToString();
//		}
//		return s;
//	}
//	#endregion GetResultString
//
//	#region PatchDataTable 拼凑多个DataTable为一个
//	/// <summary>
//	/// 拼凑多个DataTable为一个
//	/// </summary>
//	/// <param name="dataTables"></param>
//	/// <param name="sortExpression">排序字符串</param>
//	/// <returns></returns>
//	public static DataTable PatchDataTable(IList dataTables, string sortExpression)
//	{
//		DataTable dt = new System.Data.DataTable();
//		if (dataTables.Count == 0)
//		{
//			return dt;
//		}
//		dt = (dataTables[0] as DataTable).Clone();
//		foreach (DataTable m_dt in dataTables)
//		{
//			foreach (DataRow dr in m_dt.Rows)
//			{
//				dt.ImportRow(dr);
//			}
//		}
//		if (sortExpression == null || sortExpression.Trim().Length == 0 || dt.Rows.Count <= 1)
//		{
//			return dt;
//		}
//		DataTable dtNew = dt.Clone();
//		DataRow[] drs = dt.Select("" , sortExpression);
//		for (int i = 0; i < drs.Length; i++)
//		{
//			dtNew.ImportRow(drs[i]);
//		}
//		return dtNew;
//	}
//	/// <summary>
//	/// 拼凑多个DataTable为一个
//	/// </summary>
//	/// <param name="dataTables"></param>
//	/// <returns></returns>
//	public static DataTable PatchDataTable(IList dataTables)
//	{
//		return PatchDataTable(dataTables , null);
//	}
//	#endregion PatchDataTable 拼凑多个DataTable为一个
//}
//
///// <summary>
///// SqlHelperParameterCache provides functions to leverage a static cache of procedure parameters, and the
///// ability to discover parameters for stored procedures at run-time.
///// </summary>
//public sealed class SqlHelperParameterCache
//{
//	#region private methods, variables, and constructors
//
//	//Since this class provides only static methods, make the default constructor private to prevent 
//	//instances from being created with "new SqlHelperParameterCache()".
//	private SqlHelperParameterCache() { }
//
//	private static Hashtable paramCache = Hashtable.Synchronized(new Hashtable());
//
//	/// <summary>
//	/// resolve at run time the appropriate set of SqlParameters for a stored procedure
//	/// </summary>
//	/// <param name="connectionString">a valid connection string for a SqlConnection</param>
//	/// <param name="spName">the name of the stored procedure</param>
//	/// <param name="includeReturnValueParameter">whether or not to include their return value parameter</param>
//	/// <returns></returns>
//	private static SqlParameter[] DiscoverSpParameterSet(string connectionString, string spName, bool includeReturnValueParameter)
//	{
//		using (SqlConnection cn = new SqlConnection(connectionString))
//		using (SqlCommand cmd = new SqlCommand(spName, cn))
//		{
//			cn.Open();
//			cmd.CommandType = CommandType.StoredProcedure;
//
//			SqlCommandBuilder.DeriveParameters(cmd);
//
//			if (!includeReturnValueParameter)
//			{
//				cmd.Parameters.RemoveAt(0);
//			}
//
//			SqlParameter[] discoveredParameters = new SqlParameter[cmd.Parameters.Count]; ;
//
//			cmd.Parameters.CopyTo(discoveredParameters, 0);
//
//			return discoveredParameters;
//		}
//	}
//
//	//deep copy of cached SqlParameter array
//	private static SqlParameter[] CloneParameters(SqlParameter[] originalParameters)
//	{
//		SqlParameter[] clonedParameters = new SqlParameter[originalParameters.Length];
//
//		for (int i = 0, j = originalParameters.Length; i < j; i++)
//		{
//			clonedParameters[i] = (SqlParameter)((ICloneable)originalParameters[i]).Clone();
//		}
//
//		return clonedParameters;
//	}
//
//	#endregion private methods, variables, and constructors
//
//	#region caching functions
//
//	/// <summary>
//	/// add parameter array to the cache
//	/// </summary>
//	/// <param name="connectionString">a valid connection string for a SqlConnection</param>
//	/// <param name="commandText">the stored procedure name or T-SQL command</param>
//	/// <param name="commandParameters">an array of SqlParamters to be cached</param>
//	public static void CacheParameterSet(string connectionString, string commandText, params SqlParameter[] commandParameters)
//	{
//		string hashKey = connectionString + ":" + commandText;
//
//		paramCache[hashKey] = commandParameters;
//	}
//
//	/// <summary>
//	/// retrieve a parameter array from the cache
//	/// </summary>
//	/// <param name="connectionString">a valid connection string for a SqlConnection</param>
//	/// <param name="commandText">the stored procedure name or T-SQL command</param>
//	/// <returns>an array of SqlParamters</returns>
//	public static SqlParameter[] GetCachedParameterSet(string connectionString, string commandText)
//	{
//		string hashKey = connectionString + ":" + commandText;
//
//		SqlParameter[] cachedParameters = (SqlParameter[])paramCache[hashKey];
//
//		if (cachedParameters == null)
//		{
//			return null;
//		}
//		else
//		{
//			return CloneParameters(cachedParameters);
//		}
//	}
//
//	#endregion caching functions
//
//	#region Parameter Discovery Functions
//
//	/// <summary>
//	/// Retrieves the set of SqlParameters appropriate for the stored procedure
//	/// </summary>
//	/// <remarks>
//	/// This method will query the database for this information, and then store it in a cache for future requests.
//	/// </remarks>
//	/// <param name="connectionString">a valid connection string for a SqlConnection</param>
//	/// <param name="spName">the name of the stored procedure</param>
//	/// <returns>an array of SqlParameters</returns>
//	public static SqlParameter[] GetSpParameterSet(string connectionString, string spName)
//	{
//		return GetSpParameterSet(connectionString, spName, false);
//	}
//
//	/// <summary>
//	/// Retrieves the set of SqlParameters appropriate for the stored procedure
//	/// </summary>
//	/// <remarks>
//	/// This method will query the database for this information, and then store it in a cache for future requests.
//	/// </remarks>
//	/// <param name="connectionString">a valid connection string for a SqlConnection</param>
//	/// <param name="spName">the name of the stored procedure</param>
//	/// <param name="includeReturnValueParameter">a bool value indicating whether the return value parameter should be included in the results</param>
//	/// <returns>an array of SqlParameters</returns>
//	public static SqlParameter[] GetSpParameterSet(string connectionString, string spName, bool includeReturnValueParameter)
//	{
//		string hashKey = connectionString + ":" + spName + (includeReturnValueParameter ? ":include ReturnValue Parameter" : "");
//
//		SqlParameter[] cachedParameters;
//
//		cachedParameters = (SqlParameter[])paramCache[hashKey];
//
//		if (cachedParameters == null)
//		{
//			cachedParameters = (SqlParameter[])(paramCache[hashKey] = DiscoverSpParameterSet(connectionString, spName, includeReturnValueParameter));
//		}
//
//		return CloneParameters(cachedParameters);
//	}
//
//	#endregion Parameter Discovery Functions

}
